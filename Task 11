/*
  1.  მოცემულია ოთხნიშნა რიცხვი (მაგ: 2112) თუ სიმეტრიულია, result ცვლადში ჩავწეროთ true თუ არა false. თუ 4 ზე მცირე შემოვიდა წარმოვდიგნიოთ
  რომ წინ 0 ები უწერია.;
  (true : 0110; false: 10;)
*/

{
  int ABCD;
  int result;
  
  int AB;
  int CD;
  
  AB = ABCD / 100; // AB ში ვათავსებ პირველ ორ რიცხვს
  CD = ABCD % 100; // CD ში ბოლო ორ რიცხვს 
  
  C = CD / 10; // C ში მესამე რიცხსვს ( საჭიროა სამნიშნას შემთხვევაში)
  D = ABCD % 10; // D ში მეოთხე რიცხვს 
  
  if( ABCD < 100 || ABCD > 1000) // ვამოწმებ რიცხვის მნიშვნელობას. თუ რიცხვი 100 ზე ნაკლებია ან 1000 ზე მეტია, ე.ი საერთოდ არ გამოგვადგება, ამიტომ ვაბრუნებ false.
  {
    result = false;
  }
  else
  {
    if( ABCD > 100 && ABCD < 1000 && AB == C && D == 0 ) // ვამოწმბ რიცხვი არის თუ არა 3 ნიშნა, თუ სამნიშნაა ვამოწმებ ტოლია თუ არა პირველი და შუა რიცხვი. ასევე 0 ა თუ არა ბოლო ციფრი. 
  {                                                     //  თუ ტოლია, ე.ი 00 ის წინ ჩასმით 
      return = true;
  }
    else
  {
      if( ABCD > 1000 && AB == CD) // ვამოწმებ რიცხვი არის თუარა 4 ნიშნა და თუ  4 ნიშნაა პირველი ორი და ბლო ორი ციფრების ტოლობას.
  {
        result = true;
  }
          else
  {
            result = false;
  }
  
  }
  }
  
  
}

/*
  2. წარმოვიდგინოთ შახმატის დაფა. ლაზიერი -L დგას გარკვეულ ადგილას. 
  დაფაზე მას მხოლოდ შეუძლია სიარული წინ უკან გვერდით მარცხნივ და მარჯვნივ.
  
  მეორე ფიგურა -P დგას გარკვეულ ადგილას;
  
  შეუძლია თუ არა ლაზიერს პაიკის მოკვლა?
  
  
  input: 
  L1 = 2;
  L2 = 4;
  
  P1 = 3;
  P2 = 5;
  
  
  
  კოორდინატები დაფაზე:
  L1 L2 
  P1 P2
  
  
  input: 
  L1 = 2;
  L2 = 4;
  
  P1 = 3;
  P2 = 5;
  
  Output: 
  bollean
  
*/

{
  int L1;
  int L2;
  
  int P1;
  int P2;
  
  int result;
  
  
  if( L1 == P1 || L2 == P2 )
  {
    result = true;
  }
  else
  {
    result = false;
  }
  
}



/*
  3. მოცემულია 3 რიცხვი. ვიპოვოთ მაქსიმუმი.
*/

{
  int a;
  int b;
  int c;
  
  int max;
  
  if( a > b && a > c )
  {
    max = a;
  }
  else
  {
    if( b > a && b > c )
    {
      max = b;
    }
    else
    {
      if(c > a && c > b)
      {
      max = c;
      }
    }
  } 
}

/*
  
  4. ვერტიკალურად დასობილ h მეტრიან ჯოხზე მიცოცავს ლოკოკინა. ერთ დღეში აცოცდება a მეტრით და ღამით ისევ ჩამოცოცდება  b მეტრით. 
  რომელ დღეს აცოცდება ლოკოკინა ჯოხის ბოლოზე?  მოცემულია სამი ნატურალური რიცხვი h, a, b. გარანტირებულია რომ a > b.

result ცვლადში მოვათავსოთ ამოცანის პასუხი.

Input  | Output
10 3 2 | 8
20 7 3 | 5
12  10  2| 2
  
*/

{
  int h;
  int a;
  int b;
  
  int day;
  
  int daysCheck;
  
  int evenCheck;
  
  int result;
  
  day = a - b;
  
  daysCheck = h / day; // სიმაღლეს ვაკლებ დღიურ ასვლას
  
  
  evenCheck = daysCheck % 2; // ვიგებ არის თუ არა რიცხვი ლუწი
  
  
 calc =  (h - b) -1; // სიმაღლეს ვაკლებ დღიურ მინუსს და ვაკლებ კიდე ერთს
  
 final =  (calc / day) + 1; // რა დრო დაჭირდებოდა თანაბარი რო ყოფილიყო და მაღლა -1 ის გამო ვუმატებ 1 ს
  
  
  if( evenCheck == 0)
  {
    result = daysCheck;
  }
  else
  {
    if( evenCheck > 0 )
    {
      result = final;
    }
  }
 
  
}


/*

  5. კვადრატის ფორმის დაფაზე ყოველ კიდის უჯრაში მოათავსეს თითო მონეტა. შეიძლება თუ არა აღმოჩნდეს რომ ზუსტად k რაოდენობის მონეტა იყო მოთავსებული დაფაზე?
მაგალითად თუ დაფა 2x2 მაშინ კიდე უჯრებში მოთავსებული მონეტების რაოდენობაა 4
თუ 6x6 მაშინ 20 მონეტა
მოცემულია ნატურალური რიცხვი k
result ცვლადში მოვათავსოთ true თუ არსებობს ისეთი ზომის კვადრატული დაფა რომელზეც კიდე უჯრებში მოთავსდება ზუსტად k რაოდენობის მონეტა, თუ არ არსებობს false

Input | Output
20    | true
13    | false

*/

{
  int k;
  
  int check;
  
  int result;

  
  check = k % 2;
  
  if( check == 0 )
  {
    result = true;
  }
  else
  {
    result = false;
  }
  
  
  
}

















